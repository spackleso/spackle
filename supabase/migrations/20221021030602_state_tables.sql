-- This script was generated by the Schema Diff utility in pgAdmin 4
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps.

-- Extension: pg_net

-- DROP EXTENSION pg_net;

CREATE EXTENSION IF NOT EXISTS pg_net
    SCHEMA extensions
    VERSION "0.6";

CREATE TABLE IF NOT EXISTS public.price_states
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone DEFAULT now(),
    stripe_account_id text COLLATE pg_catalog."default" NOT NULL,
    state json,
    schema_version smallint NOT NULL,
    stripe_price_id text COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT price_states_pkey PRIMARY KEY (id),
    CONSTRAINT price_states_stripe_account_id_fkey FOREIGN KEY (stripe_account_id)
        REFERENCES public.stripe_accounts (stripe_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT price_states_stripe_price_id_fkey FOREIGN KEY (stripe_price_id)
        REFERENCES public.stripe_prices (stripe_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.price_states
    OWNER to supabase_admin;

ALTER TABLE IF EXISTS public.price_states
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.price_states TO anon;

GRANT ALL ON TABLE public.price_states TO postgres;

GRANT ALL ON TABLE public.price_states TO supabase_admin;

GRANT ALL ON TABLE public.price_states TO authenticated;

GRANT ALL ON TABLE public.price_states TO service_role;
CREATE POLICY "Read from Stripe dashboard"
    ON public.price_states
    AS PERMISSIVE
    FOR SELECT
    TO authenticated
    USING (((auth.jwt() ->> 'account_id'::text) = stripe_account_id));

CREATE TABLE IF NOT EXISTS public.account_states
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone DEFAULT now(),
    stripe_account_id text COLLATE pg_catalog."default" NOT NULL,
    state json,
    schema_version smallint NOT NULL,
    CONSTRAINT account_states_pkey PRIMARY KEY (id),
    CONSTRAINT account_states_stripe_account_id_fkey FOREIGN KEY (stripe_account_id)
        REFERENCES public.stripe_accounts (stripe_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.account_states
    OWNER to supabase_admin;

ALTER TABLE IF EXISTS public.account_states
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.account_states TO anon;

GRANT ALL ON TABLE public.account_states TO postgres;

GRANT ALL ON TABLE public.account_states TO supabase_admin;

GRANT ALL ON TABLE public.account_states TO authenticated;

GRANT ALL ON TABLE public.account_states TO service_role;
CREATE POLICY "Read from Stripe dashboard"
    ON public.account_states
    AS PERMISSIVE
    FOR SELECT
    TO authenticated
    USING (((auth.jwt() ->> 'account_id'::text) = stripe_account_id));

CREATE TABLE IF NOT EXISTS public.product_states
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone DEFAULT now(),
    stripe_account_id text COLLATE pg_catalog."default" NOT NULL,
    state json,
    schema_version smallint NOT NULL,
    stripe_product_id text COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT product_states_pkey PRIMARY KEY (id),
    CONSTRAINT product_states_stripe_account_id_fkey FOREIGN KEY (stripe_account_id)
        REFERENCES public.stripe_accounts (stripe_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT product_states_stripe_product_id_fkey FOREIGN KEY (stripe_product_id)
        REFERENCES public.stripe_products (stripe_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.product_states
    OWNER to supabase_admin;

ALTER TABLE IF EXISTS public.product_states
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.product_states TO anon;

GRANT ALL ON TABLE public.product_states TO postgres;

GRANT ALL ON TABLE public.product_states TO supabase_admin;

GRANT ALL ON TABLE public.product_states TO authenticated;

GRANT ALL ON TABLE public.product_states TO service_role;
CREATE POLICY "Read from the Stripe dashboard"
    ON public.product_states
    AS PERMISSIVE
    FOR SELECT
    TO authenticated
    USING (((auth.jwt() ->> 'account_id'::text) = stripe_account_id));

ALTER TABLE IF EXISTS public.stripe_prices
    ENABLE ROW LEVEL SECURITY;

ALTER TABLE IF EXISTS public.customer_features
    ENABLE ROW LEVEL SECURITY;

ALTER TABLE IF EXISTS public.stripe_subscription_items
    ENABLE ROW LEVEL SECURITY;

ALTER TABLE IF EXISTS public.stripe_products
    ENABLE ROW LEVEL SECURITY;

REVOKE ALL ON TABLE public.stripe_products FROM authenticated;
REVOKE ALL ON TABLE public.stripe_products FROM postgres;
REVOKE ALL ON TABLE public.stripe_products FROM service_role;
GRANT ALL ON TABLE public.stripe_products TO authenticated;

GRANT ALL ON TABLE public.stripe_products TO postgres;

GRANT ALL ON TABLE public.stripe_products TO service_role;

ALTER TABLE IF EXISTS public.stripe_customers
    ENABLE ROW LEVEL SECURITY;

REVOKE ALL ON TABLE public.stripe_customers FROM authenticated;
REVOKE ALL ON TABLE public.stripe_customers FROM postgres;
REVOKE ALL ON TABLE public.stripe_customers FROM service_role;
GRANT ALL ON TABLE public.stripe_customers TO authenticated;

GRANT ALL ON TABLE public.stripe_customers TO postgres;

GRANT ALL ON TABLE public.stripe_customers TO service_role;

ALTER TABLE IF EXISTS public.features
    ENABLE ROW LEVEL SECURITY;

REVOKE ALL ON TABLE public.features FROM authenticated;
REVOKE ALL ON TABLE public.features FROM postgres;
REVOKE ALL ON TABLE public.features FROM service_role;
GRANT ALL ON TABLE public.features TO authenticated;

GRANT ALL ON TABLE public.features TO postgres;

GRANT ALL ON TABLE public.features TO service_role;

ALTER TABLE IF EXISTS public.stripe_subscriptions
    ENABLE ROW LEVEL SECURITY;

ALTER TABLE IF EXISTS public.product_features
    ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Read from Stripe dashboard"
    ON public.product_features
    AS PERMISSIVE
    FOR SELECT
    TO authenticated
    USING (((auth.jwt() ->> 'account_id'::text) = stripe_account_id));

ALTER TABLE IF EXISTS public.price_features
    ENABLE ROW LEVEL SECURITY;

ALTER TABLE IF EXISTS public.stripe_accounts
    ENABLE ROW LEVEL SECURITY;

REVOKE ALL ON TABLE public.stripe_accounts FROM authenticated;
REVOKE ALL ON TABLE public.stripe_accounts FROM postgres;
REVOKE ALL ON TABLE public.stripe_accounts FROM service_role;
GRANT ALL ON TABLE public.stripe_accounts TO authenticated;

GRANT ALL ON TABLE public.stripe_accounts TO postgres;

GRANT ALL ON TABLE public.stripe_accounts TO service_role;
